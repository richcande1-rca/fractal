<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Mandelbrot Explorer</title>

  <style>
    :root { color-scheme: dark; }
    body { margin: 0; background: #0b0d10; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    #wrap { display: grid; grid-template-rows: auto 1fr; height: 100vh; }
    #ui {
      display: flex; flex-wrap: wrap; gap: 10px;
      align-items: center;
      padding: 10px 12px;
      background: rgba(20,23,28,.95);
      border-bottom: 1px solid rgba(255,255,255,.08);
      user-select: none;
    }
    button {
      background: #1c2330; color: #e7edf7;
      border: 1px solid rgba(255,255,255,.12);
      border-radius: 10px;
      padding: 8px 10px;
      cursor: pointer;
    }
    button:hover { background: #242d3d; }
    label { display: inline-flex; align-items: center; gap: 8px; color: #cbd5e1; }
    input[type="range"] { width: 220px; }
    #hud {
      margin-left: auto;
      color: #aab4c4;
      font-variant-numeric: tabular-nums;
      white-space: nowrap;
    }
    canvas { display: block; width: 100%; height: 100%; touch-action: none; }
    .hint { color:#93a4bf; opacity:.9; }
    .pill { padding: 4px 8px; border-radius: 999px; background: rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.08); }
    kbd { padding: 2px 6px; border: 1px solid rgba(255,255,255,.18); border-bottom-width: 2px; border-radius: 6px; background: rgba(255,255,255,.06); }
  </style>
</head>

<body>
<div id="wrap">
  <div id="ui">
    <button id="renderBtn">Render</button>
    <button id="resetBtn">Reset</button>
    <button id="copyBtn">Copy</button>

    <label class="pill">
      Iterations
      <input id="iter" type="range" min="50" max="2500" value="350" step="10">
      <span id="iterVal">350</span>
    </label>

    <label class="pill">
      Quality
      <input id="quality" type="range" min="0.5" max="1.5" value="0.7" step="0.1">
      <span id="qualityVal">0.7</span>
    </label>

    <span class="hint">
      Drag = pan • Shift+drag = box zoom • Click = zoom • Shift+click = out • Wheel = zoom •
      <kbd>↑</kbd><kbd>↓</kbd><kbd>←</kbd><kbd>→</kbd> pan • <kbd>Shift</kbd>+<kbd>↑</kbd> zoom in • <kbd>Shift</kbd>+<kbd>↓</kbd> zoom out •
      <kbd>Space</kbd> HQ • <kbd>R</kbd> reset
    </span>

    <div id="hud"></div>
  </div>

  <canvas id="c"></canvas>
</div>

<script>
(() => {

const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d", { willReadFrequently:true });

const iterEl = document.getElementById("iter");
const iterValEl = document.getElementById("iterVal");
const qEl = document.getElementById("quality");
const qValEl = document.getElementById("qualityVal");
const hud = document.getElementById("hud");

const renderBtn = document.getElementById("renderBtn");
const resetBtn  = document.getElementById("resetBtn");
const copyBtn   = document.getElementById("copyBtn");

// ---------------------------
// Performance tuning
// ---------------------------
const PREVIEW_FPS = 12;
const PREVIEW_QUALITY = 0.45;
const PREVIEW_ITER_MULT = 0.25;
const SETTLE_MS = 220;

// Progressive render chunk size (fixed)
const ROWS_PER_FRAME = 14;

let lastPreview = 0;
let settleTimer = null;

// Render cancellation token
let renderToken = 0;

const state = {
  cx: -0.5,
  cy: 0,
  scale: 3,
  quality: +qEl.value,
  maxIter: +iterEl.value
};

function resize() {
  const dpr = window.devicePixelRatio || 1;
  const w = Math.floor(canvas.clientWidth  * dpr * state.quality);
  const h = Math.floor(canvas.clientHeight * dpr * state.quality);
  if (canvas.width !== w || canvas.height !== h) {
    canvas.width = w;
    canvas.height = h;
  }
}

function updateHUD(iter = state.maxIter) {
  const f = v => Math.abs(v) < 1e-3 ? v.toExponential(3) : v.toFixed(6);
  hud.textContent = `cx ${f(state.cx)}  cy ${f(state.cy)}  scale ${state.scale.toExponential(3)}  iter ${iter}`;
}

function pixelToComplex(px, py) {
  const w = canvas.width, h = canvas.height;
  const aspect = w / h;
  const vw = state.scale;
  const vh = state.scale / aspect;

  return {
    x: state.cx + (px / w - .5) * vw,
    y: state.cy + (py / h - .5) * vh
  };
}

function isInside(cx, cy) {
  const x = cx - 0.25, y = cy;
  const q = x*x + y*y;
  if (q*(q + x) <= 0.25*y*y) return true;
  const x2 = cx + 1.0;
  if (x2*x2 + cy*cy <= 0.0625) return true;
  return false;
}

function color(t) {
  const a = 0.5, b = 0.5;
  const TAU = 6.283185307179586;
  const r = a + b * Math.cos(TAU * (t));
  const g = a + b * Math.cos(TAU * (t + 0.33));
  const b2 = a + b * Math.cos(TAU * (t + 0.67));
  return [ (r*255)|0, (g*255)|0, (b2*255)|0, 255 ];
}

// ---------------------------
// Progressive, cancelable renderer
// ---------------------------
function renderProgressive(maxIter) {
  const token = ++renderToken;

  const w = canvas.width, h = canvas.height;
  const img = ctx.createImageData(w, h);
  const d = img.data;

  const aspect = w / h;
  const vw = state.scale;
  const vh = vw / aspect;

  const x0 = state.cx - vw / 2;
  const y0 = state.cy - vh / 2;
  const dx = vw / w;
  const dy = vh / h;

  let py = 0;

  function step() {
    if (token !== renderToken) return;

    const yEnd = Math.min(h, py + ROWS_PER_FRAME);

    for (; py < yEnd; py++) {
      const cy = y0 + py * dy;
      let p = py * w * 4;

      for (let px = 0; px < w; px++) {
        const cx = x0 + px * dx;

        if (isInside(cx, cy)) {
          d[p++] = 5; d[p++] = 6; d[p++] = 8; d[p++] = 255;
          continue;
        }

        let zx = 0, zy = 0, i = 0, ox = 0, oy = 0;

        while (i < maxIter) {
          const zx2 = zx*zx - zy*zy + cx;
          const zy2 = 2*zx*zy + cy;
          zx = zx2; zy = zy2;

          if (zx*zx + zy*zy > 4) break;

          if ((i & 31) === 0) {
            if (Math.abs(zx - ox) < 1e-12 && Math.abs(zy - oy) < 1e-12) {
              i = maxIter; break;
            }
            ox = zx; oy = zy;
          }
          i++;
        }

        if (i === maxIter) {
          d[p++] = 5; d[p++] = 6; d[p++] = 8; d[p++] = 255;
        } else {
          const mu = i + 1 - Math.log(Math.log(Math.sqrt(zx*zx + zy*zy))) / Math.LN2;
          const t = (mu / maxIter) * 1.25;
          const c = color(t);
          d[p++] = c[0]; d[p++] = c[1]; d[p++] = c[2]; d[p++] = 255;
        }
      }
    }

    ctx.putImageData(img, 0, 0);

    if (py < h) requestAnimationFrame(step);
    else updateHUD(maxIter);
  }

  requestAnimationFrame(step);
}

function cancelRender() { renderToken++; }

// ---------------------------
// Render modes
// ---------------------------
function renderHQ() {
  cancelRender();
  state.quality = +qEl.value;
  resize();
  renderProgressive(+iterEl.value);
}

function renderPreviewThrottled() {
  const now = performance.now();
  if (now - lastPreview < (1000 / PREVIEW_FPS)) return;
  lastPreview = now;

  cancelRender();

  state.quality = PREVIEW_QUALITY;
  resize();
  const baseIter = +iterEl.value;
  const previewIter = Math.max(50, (baseIter * PREVIEW_ITER_MULT) | 0);

  renderProgressive(previewIter);

  clearTimeout(settleTimer);
  settleTimer = setTimeout(renderHQ, SETTLE_MS);
}

function zoomAt(px, py, factor) {
  const before = pixelToComplex(px, py);
  state.scale *= factor;
  const after = pixelToComplex(px, py);
  state.cx += (before.x - after.x);
  state.cy += (before.y - after.y);
}

// ---------------------------
// Mouse / touchpad
// ---------------------------
let dragging = false, box = false;
let last = { x: 0, y: 0 }, boxStart = null;

canvas.addEventListener("mousedown", (e) => {
  dragging = true;
  const x = e.offsetX * (canvas.width / canvas.clientWidth);
  const y = e.offsetY * (canvas.height / canvas.clientHeight);
  last = { x, y };
  box = e.shiftKey;
  boxStart = box ? { x, y } : null;
});

canvas.addEventListener("mousemove", (e) => {
  if (!dragging) return;

  const x = e.offsetX * (canvas.width / canvas.clientWidth);
  const y = e.offsetY * (canvas.height / canvas.clientHeight);

  const dx = x - last.x;
  const dy = y - last.y;
  last = { x, y };

  if (!box) {
    const vw = state.scale;
    const vh = state.scale / (canvas.width / canvas.height);
    state.cx -= dx * (vw / canvas.width);
    state.cy -= dy * (vh / canvas.height);
  }

  renderPreviewThrottled();
});

window.addEventListener("mouseup", () => {
  if (!dragging) return;
  dragging = false;

  if (box && boxStart) {
    const x1 = boxStart.x, y1 = boxStart.y;
    const x2 = last.x,     y2 = last.y;

    const xMin = Math.min(x1, x2), xMax = Math.max(x1, x2);
    const yMin = Math.min(y1, y2), yMax = Math.max(y1, y2);

    const selW = Math.max(2, xMax - xMin);
    const selH = Math.max(2, yMax - yMin);

    const cA = pixelToComplex(xMin, yMin);
    const cB = pixelToComplex(xMax, yMax);
    state.cx = (cA.x + cB.x) / 2;
    state.cy = (cA.y + cB.y) / 2;

    const w = canvas.width, h = canvas.height;
    const aspect = w / h;

    const scaleX = state.scale * (selW / w);
    const viewH = state.scale / aspect;
    const scaleY = viewH * (selH / h);
    state.scale = Math.max(scaleX, scaleY * aspect);
  }

  box = false;
  boxStart = null;

  renderHQ();
});

canvas.addEventListener("click", (e) => {
  if (dragging) return;

  const px = e.offsetX * (canvas.width /*
