<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Mandelbrot Explorer</title>
  <style>
    :root { color-scheme: dark; }
    body { margin: 0; background: #0b0d10; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    #wrap { display: grid; grid-template-rows: auto 1fr; height: 100vh; }
    #ui {
      display: flex; flex-wrap: wrap; gap: 10px;
      align-items: center;
      padding: 10px 12px;
      background: rgba(20, 23, 28, 0.95);
      border-bottom: 1px solid rgba(255,255,255,0.08);
      user-select: none;
    }
    button {
      background: #1c2330; color: #e7edf7;
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 10px;
      padding: 8px 10px;
      cursor: pointer;
    }
    button:hover { background: #242d3d; }
    label { display: inline-flex; align-items: center; gap: 8px; color: #cbd5e1; }
    input[type="range"] { width: 220px; }
    #hud {
      margin-left: auto;
      color: #aab4c4;
      opacity: 0.95;
      font-variant-numeric: tabular-nums;
      white-space: nowrap;
    }
    canvas { display: block; width: 100%; height: 100%; touch-action: none; }
    .hint { color:#93a4bf; opacity:0.9; }
    .pill { padding: 4px 8px; border-radius: 999px; background: rgba(255,255,255,0.06); border:1px solid rgba(255,255,255,0.08); }
    kbd { padding: 2px 6px; border: 1px solid rgba(255,255,255,0.18); border-bottom-width: 2px; border-radius: 6px; background: rgba(255,255,255,0.06); }
  </style>
</head>
<body>
<div id="wrap">
  <div id="ui">
    <button id="renderBtn" title="HQ render (Space)">Render</button>
    <button id="resetBtn"  title="Reset (R)">Reset</button>

    <label class="pill">
      Iterations
      <input id="iter" type="range" min="50" max="2500" value="350" step="10" />
      <span id="iterVal">350</span>
    </label>

    <label class="pill">
      Quality
      <input id="quality" type="range" min="0.5" max="1.5" value="0.7" step="0.1" />
      <span id="qualityVal">0.7</span>
    </label>

    <span class="hint">
      Drag = pan • Two-finger scroll = zoom • Click = zoom in • <kbd>Shift</kbd>+Click = zoom out •
      <kbd>↑</kbd>/<kbd>↓</kbd> zoom • <kbd>←</kbd>/<kbd>→</kbd> pan • <kbd>Space</kbd> HQ render • <kbd>R</kbd> reset
    </span>

    <div id="hud"></div>
  </div>

  <canvas id="c"></canvas>
</div>

<script>
(() => {
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d", { willReadFrequently: true });

  const iterEl = document.getElementById("iter");
  const iterValEl = document.getElementById("iterVal");
  const qEl = document.getElementById("quality");
  const qValEl = document.getElementById("qualityVal");
  const hud = document.getElementById("hud");
  const renderBtn = document.getElementById("renderBtn");
  const resetBtn  = document.getElementById("resetBtn");

  // View state
  const state = {
    cx: -0.5,
    cy: 0.0,
    scale: 3.0,        // width of view in complex units
    maxIter: +iterEl.value,
    quality: +qEl.value
  };

  // ---------------------------
  // Performance tuning (Chromebook-friendly)
  // ---------------------------
  const PREVIEW_FPS = 12;         // cap preview redraw rate while moving
  const PREVIEW_QUALITY = 0.45;   // lower render resolution while moving
  const PREVIEW_ITER_MULT = 0.25; // fewer iterations while moving
  const SETTLE_MS = 220;          // after motion stops, do a HQ render

  let lastPreview = 0;
  let settleTimer = null;

  function resize() {
    const dpr = window.devicePixelRatio || 1;
    const q = state.quality;
    const w = Math.floor(canvas.clientWidth  * dpr * q);
    const h = Math.floor(canvas.clientHeight * dpr * q);
    if (canvas.width !== w || canvas.height !== h) {
      canvas.width = w;
      canvas.height = h;
    }
  }

  window.addEventListener("resize", () => {
    state.quality = +qEl.value;
    resize();
    renderHQ();
  });

  function updateHUD() {
    const digits = (v) => (Math.abs(v) < 1e-3 ? v.toExponential(3) : v.toFixed(6));
    hud.textContent =
      `cx ${digits(state.cx)}  cy ${digits(state.cy)}  scale ${state.scale.toExponential(3)}  iter ${state.maxIter}`;
  }

  // Screen pixel -> complex plane
  function pixelToComplex(px, py) {
    const w = canvas.width, h = canvas.height;
    const aspect = w / h;
    const viewW = state.scale;
    const viewH = state.scale / aspect;

    const x = state.cx + (px / w - 0.5) * viewW;
    const y = state.cy + (py / h - 0.5) * viewH;
    return { x, y };
  }

  function smoothIter(i, zx, zy) {
    const mag = Math.sqrt(zx*zx + zy*zy);
    if (mag <= 0) return i;
    return i + 1 - Math.log(Math.log(mag)) / Math.LN2;
  }

  // Cosine palette (smooth)
  function colorFromT(t) {
    const a = 0.5, b = 0.5;
    const d1 = 0.00, d2 = 0.33, d3 = 0.67;
    const r = a + b * Math.cos(2*Math.PI*(t + d1));
    const g = a + b * Math.cos(2*Math.PI*(t + d2));
    const bb = a + b * Math.cos(2*Math.PI*(t + d3));
    return [
      Math.max(0, Math.min(255, (r * 255) | 0)),
      Math.max(0, Math.min(255, (g * 255) | 0)),
      Math.max(0, Math.min(255, (bb * 255) | 0)),
      255
    ];
  }

  // Fast inside checks for Mandelbrot (BIG speedup)
  function isDefinitelyInside(cx, cy) {
    // Main cardioid test
    const x = cx - 0.25;
    const y = cy;
    const q = x*x + y*y;
    if (q * (q + x) <= 0.25 * y*y) return true;

    // Period-2 bulb test (center -1, radius 1/4)
    const x2 = cx + 1.0;
    if (x2*x2 + cy*cy <= 0.0625) return true; // (1/4)^2

    return false;
  }

  function renderWith(maxIter) {
    const w = canvas.width, h = canvas.height;
    const img = ctx.createImageData(w, h);
    const data = img.data;

    const aspect = w / h;
    const viewW = state.scale;
    const viewH = state.scale / aspect;

    const x0 = state.cx - viewW / 2;
    const y0 = state.cy - viewH / 2;
    const dx = viewW / w;
    const dy = viewH / h;

    let p = 0;
    for (let py = 0; py < h; py++) {
      const cy = y0 + py * dy;
      for (let px = 0; px < w; px++) {
        const cx = x0 + px * dx;

        // Inside shortcuts (huge speed win)
        if (isDefinitelyInside(cx, cy)) {
          data[p++] = 5; data[p++] = 6; data[p++] = 8; data[p++] = 255;
          continue;
        }

        // Escape-time iteration
        let zx = 0, zy = 0, i = 0;
        while (i < maxIter) {
          const zx2 = zx*zx - zy*zy + cx;
          const zy2 = 2*zx*zy + cy;
          zx = zx2; zy = zy2;

          if (zx*zx + zy*zy > 4) break;
          i++;
        }

        if (i === maxIter) {
          data[p++] = 5; data[p++] = 6; data[p++] = 8; data[p++] = 255;
        } else {
          const mu = smoothIter(i, zx, zy);
          const t = (mu / maxIter) * 1.25;
          const col = colorFromT(t);
          data[p++] = col[0]; data[p++] = col[1]; data[p++] = col[2]; data[p++] = 255;
        }
      }
    }

    ctx.putImageData(img, 0, 0);
    state.maxIter = maxIter;
    updateHUD();
  }

  function renderHQ() {
    state.quality = +qEl.value;
    resize();
    const baseIter = +iterEl.value;
    renderWith(baseIter);
  }

  function scheduleHQRenderSoon() {
    clearTimeout(settleTimer);
    settleTimer = setTimeout(() => {
      renderHQ();
    }, SETTLE_MS);
  }

  function renderPreviewThrottled() {
    const now = performance.now();
    if (now - lastPreview < (1000 / PREVIEW_FPS)) return;
    lastPreview = now;

    // Preview settings
    state.quality = PREVIEW_QUALITY;
    resize();
    const baseIter = +iterEl.value;
    const previewIter = Math.max(50, Math.floor(baseIter * PREVIEW_ITER_MULT));
    renderWith(previewIter);

    // HQ render will restore quality after you stop
    scheduleHQRenderSoon();
  }

  // Zoom toward a screen point
  function zoomAt(px, py, factor) {
    const before = pixelToComplex(px, py);
    state.scale *= factor;
    const after = pixelToComplex(px, py);
    state.cx += (before.x - after.x);
    state.cy += (before.y - after.y);
  }

  // Pan by pixel delta
  function panByPixels(dxPx, dyPx) {
    const w = canvas.width, h = canvas.height;
    const aspect = w / h;
    const viewW = state.scale;
    const viewH = state.scale / aspect;
    state.cx -= dxPx * (viewW / w);
    state.cy -= dyPx * (viewH / h);
  }

  // ---------------------------
  // Touchpad / Mouse
  // ---------------------------
  let dragging = false;
  let last = { x: 0, y: 0 };

  canvas.addEventListener("mousedown", (e) => {
    dragging = true;
    last.x = e.offsetX * (canvas.width / canvas.clientWidth);
    last.y = e.offsetY * (canvas.height / canvas.clientHeight);
  });

  window.addEventListener("mouseup", () => {
    if (dragging) scheduleHQRenderSoon();
    dragging = false;
  });

  canvas.addEventListener("mousemove", (e) => {
    if (!dragging) return;

    const x = e.offsetX * (canvas.width / canvas.clientWidth);
    const y = e.offsetY * (canvas.height / canvas.clientHeight);
    const dx = x - last.x;
    const dy = y - last.y;
    last.x = x; last.y = y;

    panByPixels(dx, dy);
    renderPreviewThrottled();
  });

  canvas.addEventListener("click", (e) => {
    if (dragging) return;

    const px = e.offsetX * (canvas.width / canvas.clientWidth);
    const py = e.offsetY * (canvas.height / canvas.clientHeight);
    const factor = e.shiftKey ? 1.8 : 0.55;

    zoomAt(px, py, factor);
    renderPreviewThrottled();
  });

  canvas.addEventListener("wheel", (e) => {
    e.preventDefault();
    const px = e.offsetX * (canvas.width / canvas.clientWidth);
    const py = e.offsetY * (canvas.height / canvas.clientHeight);

    const zoomFactor = Math.exp(e.deltaY * 0.0015);
    zoomAt(px, py, zoomFactor);

    renderPreviewThrottled();
  }, { passive: false });

  // ---------------------------
  // Keyboard: smooth + preview/HQ settle
  // ---------------------------
  const keys = { up:false, down:false, left:false, right:false };

  window.addEventListener("keydown", (e) => {
    if (e.key === "ArrowUp")    keys.up = true;
    if (e.key === "ArrowDown")  keys.down = true;
    if (e.key === "ArrowLeft")  keys.left = true;
    if (e.key === "ArrowRight") keys.right = true;

    if (e.key.toLowerCase() === "r") {
      resetView();
      renderHQ();
    }

    if (e.key === " ") {
      e.preventDefault();
      renderHQ();
    }
  });

  window.addEventListener("keyup", (e) => {
    if (e.key === "ArrowUp")    keys.up = false;
    if (e.key === "ArrowDown")  keys.down = false;
    if (e.key === "ArrowLeft")  keys.left = false;
    if (e.key === "ArrowRight") keys.right = false;

    scheduleHQRenderSoon();
  });

  function controlLoop() {
    let moved = false;

    // Zoom (hold for continuous)
    if (keys.up)   { state.scale *= 0.985; moved = true; }
    if (keys.down) { state.scale *= 1.015; moved = true; }

    // Pan (left/right only)
    const panSpeed = state.scale * 0.02;
    if (keys.left)  { state.cx -= panSpeed; moved = true; }
    if (keys.right) { state.cx += panSpeed; moved = true; }

    if (moved) renderPreviewThrottled();

    requestAnimationFrame(controlLoop);
  }

  // ---------------------------
  // UI wiring
  // ---------------------------
  function resetView() {
    state.cx = -0.5;
    state.cy = 0.0;
    state.scale = 3.0;
  }

  iterEl.addEventListener("input", () => {
    iterValEl.textContent = iterEl.value;
  });
  iterEl.addEventListener("change", () => {
    renderHQ();
  });

  qEl.addEventListener("input", () => {
    qValEl.textContent = (+qEl.value).toFixed(1);
    state.quality = +qEl.value;
    resize();
    renderHQ();
  });

  renderBtn.addEventListener("click", () => renderHQ());

  resetBtn.addEventListener("click", () => {
    resetView();
    iterEl.value = 350; iterValEl.textContent = "350";
    qEl.value = 0.7;    qValEl.textContent = "0.7";
    state.quality = 0.7;
    resize();
    renderHQ();
  });

  // Boot
  iterValEl.textContent = iterEl.value;
  qValEl.textContent = (+qEl.value).toFixed(1);
  state.quality = +qEl.value;
  resize();
  renderHQ();
  controlLoop();
})();
</script>
</body>
</html>
